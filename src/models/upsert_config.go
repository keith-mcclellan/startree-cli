// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// UpsertConfig upsert config
//
// swagger:model UpsertConfig
type UpsertConfig struct {

	// comparison column
	ComparisonColumn string `json:"comparisonColumn,omitempty"`

	// default partial upsert strategy
	// Enum: [APPEND IGNORE INCREMENT MAX MIN OVERWRITE UNION]
	DefaultPartialUpsertStrategy string `json:"defaultPartialUpsertStrategy,omitempty"`

	// enable snapshot
	EnableSnapshot bool `json:"enableSnapshot,omitempty"`

	// hash function
	// Enum: [NONE MD5 MURMUR3]
	HashFunction string `json:"hashFunction,omitempty"`

	// metadata manager class
	MetadataManagerClass string `json:"metadataManagerClass,omitempty"`

	// metadata manager configs
	MetadataManagerConfigs map[string]string `json:"metadataManagerConfigs,omitempty"`

	// mode
	// Required: true
	// Read Only: true
	// Enum: [FULL PARTIAL NONE]
	Mode string `json:"mode"`

	// partial upsert strategies
	PartialUpsertStrategies map[string]string `json:"partialUpsertStrategies,omitempty"`
}

// Validate validates this upsert config
func (m *UpsertConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDefaultPartialUpsertStrategy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHashFunction(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePartialUpsertStrategies(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var upsertConfigTypeDefaultPartialUpsertStrategyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["APPEND","IGNORE","INCREMENT","MAX","MIN","OVERWRITE","UNION"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		upsertConfigTypeDefaultPartialUpsertStrategyPropEnum = append(upsertConfigTypeDefaultPartialUpsertStrategyPropEnum, v)
	}
}

const (

	// UpsertConfigDefaultPartialUpsertStrategyAPPEND captures enum value "APPEND"
	UpsertConfigDefaultPartialUpsertStrategyAPPEND string = "APPEND"

	// UpsertConfigDefaultPartialUpsertStrategyIGNORE captures enum value "IGNORE"
	UpsertConfigDefaultPartialUpsertStrategyIGNORE string = "IGNORE"

	// UpsertConfigDefaultPartialUpsertStrategyINCREMENT captures enum value "INCREMENT"
	UpsertConfigDefaultPartialUpsertStrategyINCREMENT string = "INCREMENT"

	// UpsertConfigDefaultPartialUpsertStrategyMAX captures enum value "MAX"
	UpsertConfigDefaultPartialUpsertStrategyMAX string = "MAX"

	// UpsertConfigDefaultPartialUpsertStrategyMIN captures enum value "MIN"
	UpsertConfigDefaultPartialUpsertStrategyMIN string = "MIN"

	// UpsertConfigDefaultPartialUpsertStrategyOVERWRITE captures enum value "OVERWRITE"
	UpsertConfigDefaultPartialUpsertStrategyOVERWRITE string = "OVERWRITE"

	// UpsertConfigDefaultPartialUpsertStrategyUNION captures enum value "UNION"
	UpsertConfigDefaultPartialUpsertStrategyUNION string = "UNION"
)

// prop value enum
func (m *UpsertConfig) validateDefaultPartialUpsertStrategyEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, upsertConfigTypeDefaultPartialUpsertStrategyPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *UpsertConfig) validateDefaultPartialUpsertStrategy(formats strfmt.Registry) error {
	if swag.IsZero(m.DefaultPartialUpsertStrategy) { // not required
		return nil
	}

	// value enum
	if err := m.validateDefaultPartialUpsertStrategyEnum("defaultPartialUpsertStrategy", "body", m.DefaultPartialUpsertStrategy); err != nil {
		return err
	}

	return nil
}

var upsertConfigTypeHashFunctionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["NONE","MD5","MURMUR3"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		upsertConfigTypeHashFunctionPropEnum = append(upsertConfigTypeHashFunctionPropEnum, v)
	}
}

const (

	// UpsertConfigHashFunctionNONE captures enum value "NONE"
	UpsertConfigHashFunctionNONE string = "NONE"

	// UpsertConfigHashFunctionMD5 captures enum value "MD5"
	UpsertConfigHashFunctionMD5 string = "MD5"

	// UpsertConfigHashFunctionMURMUR3 captures enum value "MURMUR3"
	UpsertConfigHashFunctionMURMUR3 string = "MURMUR3"
)

// prop value enum
func (m *UpsertConfig) validateHashFunctionEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, upsertConfigTypeHashFunctionPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *UpsertConfig) validateHashFunction(formats strfmt.Registry) error {
	if swag.IsZero(m.HashFunction) { // not required
		return nil
	}

	// value enum
	if err := m.validateHashFunctionEnum("hashFunction", "body", m.HashFunction); err != nil {
		return err
	}

	return nil
}

var upsertConfigTypeModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["FULL","PARTIAL","NONE"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		upsertConfigTypeModePropEnum = append(upsertConfigTypeModePropEnum, v)
	}
}

const (

	// UpsertConfigModeFULL captures enum value "FULL"
	UpsertConfigModeFULL string = "FULL"

	// UpsertConfigModePARTIAL captures enum value "PARTIAL"
	UpsertConfigModePARTIAL string = "PARTIAL"

	// UpsertConfigModeNONE captures enum value "NONE"
	UpsertConfigModeNONE string = "NONE"
)

// prop value enum
func (m *UpsertConfig) validateModeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, upsertConfigTypeModePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *UpsertConfig) validateMode(formats strfmt.Registry) error {

	if err := validate.RequiredString("mode", "body", m.Mode); err != nil {
		return err
	}

	// value enum
	if err := m.validateModeEnum("mode", "body", m.Mode); err != nil {
		return err
	}

	return nil
}

// additional properties value enum
var upsertConfigPartialUpsertStrategiesValueEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["APPEND","IGNORE","INCREMENT","MAX","MIN","OVERWRITE","UNION"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		upsertConfigPartialUpsertStrategiesValueEnum = append(upsertConfigPartialUpsertStrategiesValueEnum, v)
	}
}

func (m *UpsertConfig) validatePartialUpsertStrategiesValueEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, upsertConfigPartialUpsertStrategiesValueEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *UpsertConfig) validatePartialUpsertStrategies(formats strfmt.Registry) error {
	if swag.IsZero(m.PartialUpsertStrategies) { // not required
		return nil
	}

	for k := range m.PartialUpsertStrategies {

		// value enum
		if err := m.validatePartialUpsertStrategiesValueEnum("partialUpsertStrategies"+"."+k, "body", m.PartialUpsertStrategies[k]); err != nil {
			return err
		}

	}

	return nil
}

// ContextValidate validate this upsert config based on the context it is used
func (m *UpsertConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateMode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *UpsertConfig) contextValidateMode(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "mode", "body", string(m.Mode)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *UpsertConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *UpsertConfig) UnmarshalBinary(b []byte) error {
	var res UpsertConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
