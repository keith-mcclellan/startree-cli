// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// TimeGranularitySpec time granularity spec
//
// swagger:model TimeGranularitySpec
type TimeGranularitySpec struct {

	// data type
	// Enum: [INT LONG FLOAT DOUBLE BIG_DECIMAL BOOLEAN TIMESTAMP STRING JSON BYTES STRUCT MAP LIST]
	DataType string `json:"dataType,omitempty"`

	// name
	Name string `json:"name,omitempty"`

	// time format
	TimeFormat string `json:"timeFormat,omitempty"`

	// time type
	// Enum: [NANOSECONDS MICROSECONDS MILLISECONDS SECONDS MINUTES HOURS DAYS]
	TimeType string `json:"timeType,omitempty"`

	// time unit size
	TimeUnitSize int32 `json:"timeUnitSize,omitempty"`
}

// Validate validates this time granularity spec
func (m *TimeGranularitySpec) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDataType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimeType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var timeGranularitySpecTypeDataTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["INT","LONG","FLOAT","DOUBLE","BIG_DECIMAL","BOOLEAN","TIMESTAMP","STRING","JSON","BYTES","STRUCT","MAP","LIST"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		timeGranularitySpecTypeDataTypePropEnum = append(timeGranularitySpecTypeDataTypePropEnum, v)
	}
}

const (

	// TimeGranularitySpecDataTypeINT captures enum value "INT"
	TimeGranularitySpecDataTypeINT string = "INT"

	// TimeGranularitySpecDataTypeLONG captures enum value "LONG"
	TimeGranularitySpecDataTypeLONG string = "LONG"

	// TimeGranularitySpecDataTypeFLOAT captures enum value "FLOAT"
	TimeGranularitySpecDataTypeFLOAT string = "FLOAT"

	// TimeGranularitySpecDataTypeDOUBLE captures enum value "DOUBLE"
	TimeGranularitySpecDataTypeDOUBLE string = "DOUBLE"

	// TimeGranularitySpecDataTypeBIGDECIMAL captures enum value "BIG_DECIMAL"
	TimeGranularitySpecDataTypeBIGDECIMAL string = "BIG_DECIMAL"

	// TimeGranularitySpecDataTypeBOOLEAN captures enum value "BOOLEAN"
	TimeGranularitySpecDataTypeBOOLEAN string = "BOOLEAN"

	// TimeGranularitySpecDataTypeTIMESTAMP captures enum value "TIMESTAMP"
	TimeGranularitySpecDataTypeTIMESTAMP string = "TIMESTAMP"

	// TimeGranularitySpecDataTypeSTRING captures enum value "STRING"
	TimeGranularitySpecDataTypeSTRING string = "STRING"

	// TimeGranularitySpecDataTypeJSON captures enum value "JSON"
	TimeGranularitySpecDataTypeJSON string = "JSON"

	// TimeGranularitySpecDataTypeBYTES captures enum value "BYTES"
	TimeGranularitySpecDataTypeBYTES string = "BYTES"

	// TimeGranularitySpecDataTypeSTRUCT captures enum value "STRUCT"
	TimeGranularitySpecDataTypeSTRUCT string = "STRUCT"

	// TimeGranularitySpecDataTypeMAP captures enum value "MAP"
	TimeGranularitySpecDataTypeMAP string = "MAP"

	// TimeGranularitySpecDataTypeLIST captures enum value "LIST"
	TimeGranularitySpecDataTypeLIST string = "LIST"
)

// prop value enum
func (m *TimeGranularitySpec) validateDataTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, timeGranularitySpecTypeDataTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TimeGranularitySpec) validateDataType(formats strfmt.Registry) error {
	if swag.IsZero(m.DataType) { // not required
		return nil
	}

	// value enum
	if err := m.validateDataTypeEnum("dataType", "body", m.DataType); err != nil {
		return err
	}

	return nil
}

var timeGranularitySpecTypeTimeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["NANOSECONDS","MICROSECONDS","MILLISECONDS","SECONDS","MINUTES","HOURS","DAYS"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		timeGranularitySpecTypeTimeTypePropEnum = append(timeGranularitySpecTypeTimeTypePropEnum, v)
	}
}

const (

	// TimeGranularitySpecTimeTypeNANOSECONDS captures enum value "NANOSECONDS"
	TimeGranularitySpecTimeTypeNANOSECONDS string = "NANOSECONDS"

	// TimeGranularitySpecTimeTypeMICROSECONDS captures enum value "MICROSECONDS"
	TimeGranularitySpecTimeTypeMICROSECONDS string = "MICROSECONDS"

	// TimeGranularitySpecTimeTypeMILLISECONDS captures enum value "MILLISECONDS"
	TimeGranularitySpecTimeTypeMILLISECONDS string = "MILLISECONDS"

	// TimeGranularitySpecTimeTypeSECONDS captures enum value "SECONDS"
	TimeGranularitySpecTimeTypeSECONDS string = "SECONDS"

	// TimeGranularitySpecTimeTypeMINUTES captures enum value "MINUTES"
	TimeGranularitySpecTimeTypeMINUTES string = "MINUTES"

	// TimeGranularitySpecTimeTypeHOURS captures enum value "HOURS"
	TimeGranularitySpecTimeTypeHOURS string = "HOURS"

	// TimeGranularitySpecTimeTypeDAYS captures enum value "DAYS"
	TimeGranularitySpecTimeTypeDAYS string = "DAYS"
)

// prop value enum
func (m *TimeGranularitySpec) validateTimeTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, timeGranularitySpecTypeTimeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TimeGranularitySpec) validateTimeType(formats strfmt.Registry) error {
	if swag.IsZero(m.TimeType) { // not required
		return nil
	}

	// value enum
	if err := m.validateTimeTypeEnum("timeType", "body", m.TimeType); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this time granularity spec based on context it is used
func (m *TimeGranularitySpec) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TimeGranularitySpec) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TimeGranularitySpec) UnmarshalBinary(b []byte) error {
	var res TimeGranularitySpec
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
