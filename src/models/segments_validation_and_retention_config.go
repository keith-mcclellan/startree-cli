// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// SegmentsValidationAndRetentionConfig segments validation and retention config
//
// swagger:model SegmentsValidationAndRetentionConfig
type SegmentsValidationAndRetentionConfig struct {

	// completion config
	CompletionConfig *CompletionConfig `json:"completionConfig,omitempty"`

	// crypter class name
	CrypterClassName string `json:"crypterClassName,omitempty"`

	// deleted segments retention period
	DeletedSegmentsRetentionPeriod string `json:"deletedSegmentsRetentionPeriod,omitempty"`

	// minimize data movement
	MinimizeDataMovement bool `json:"minimizeDataMovement,omitempty"`

	// peer segment download scheme
	PeerSegmentDownloadScheme string `json:"peerSegmentDownloadScheme,omitempty"`

	// replica group strategy config
	ReplicaGroupStrategyConfig *ReplicaGroupStrategyConfig `json:"replicaGroupStrategyConfig,omitempty"`

	// replicas per partition
	ReplicasPerPartition string `json:"replicasPerPartition,omitempty"`

	// replication
	Replication string `json:"replication,omitempty"`

	// retention time unit
	RetentionTimeUnit string `json:"retentionTimeUnit,omitempty"`

	// retention time value
	RetentionTimeValue string `json:"retentionTimeValue,omitempty"`

	// schema name
	SchemaName string `json:"schemaName,omitempty"`

	// segment assignment strategy
	SegmentAssignmentStrategy string `json:"segmentAssignmentStrategy,omitempty"`

	// segment push frequency
	SegmentPushFrequency string `json:"segmentPushFrequency,omitempty"`

	// segment push type
	SegmentPushType string `json:"segmentPushType,omitempty"`

	// time column name
	TimeColumnName string `json:"timeColumnName,omitempty"`

	// time type
	// Enum: [NANOSECONDS MICROSECONDS MILLISECONDS SECONDS MINUTES HOURS DAYS]
	TimeType string `json:"timeType,omitempty"`
}

// Validate validates this segments validation and retention config
func (m *SegmentsValidationAndRetentionConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCompletionConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReplicaGroupStrategyConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimeType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SegmentsValidationAndRetentionConfig) validateCompletionConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.CompletionConfig) { // not required
		return nil
	}

	if m.CompletionConfig != nil {
		if err := m.CompletionConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("completionConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("completionConfig")
			}
			return err
		}
	}

	return nil
}

func (m *SegmentsValidationAndRetentionConfig) validateReplicaGroupStrategyConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.ReplicaGroupStrategyConfig) { // not required
		return nil
	}

	if m.ReplicaGroupStrategyConfig != nil {
		if err := m.ReplicaGroupStrategyConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("replicaGroupStrategyConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("replicaGroupStrategyConfig")
			}
			return err
		}
	}

	return nil
}

var segmentsValidationAndRetentionConfigTypeTimeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["NANOSECONDS","MICROSECONDS","MILLISECONDS","SECONDS","MINUTES","HOURS","DAYS"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		segmentsValidationAndRetentionConfigTypeTimeTypePropEnum = append(segmentsValidationAndRetentionConfigTypeTimeTypePropEnum, v)
	}
}

const (

	// SegmentsValidationAndRetentionConfigTimeTypeNANOSECONDS captures enum value "NANOSECONDS"
	SegmentsValidationAndRetentionConfigTimeTypeNANOSECONDS string = "NANOSECONDS"

	// SegmentsValidationAndRetentionConfigTimeTypeMICROSECONDS captures enum value "MICROSECONDS"
	SegmentsValidationAndRetentionConfigTimeTypeMICROSECONDS string = "MICROSECONDS"

	// SegmentsValidationAndRetentionConfigTimeTypeMILLISECONDS captures enum value "MILLISECONDS"
	SegmentsValidationAndRetentionConfigTimeTypeMILLISECONDS string = "MILLISECONDS"

	// SegmentsValidationAndRetentionConfigTimeTypeSECONDS captures enum value "SECONDS"
	SegmentsValidationAndRetentionConfigTimeTypeSECONDS string = "SECONDS"

	// SegmentsValidationAndRetentionConfigTimeTypeMINUTES captures enum value "MINUTES"
	SegmentsValidationAndRetentionConfigTimeTypeMINUTES string = "MINUTES"

	// SegmentsValidationAndRetentionConfigTimeTypeHOURS captures enum value "HOURS"
	SegmentsValidationAndRetentionConfigTimeTypeHOURS string = "HOURS"

	// SegmentsValidationAndRetentionConfigTimeTypeDAYS captures enum value "DAYS"
	SegmentsValidationAndRetentionConfigTimeTypeDAYS string = "DAYS"
)

// prop value enum
func (m *SegmentsValidationAndRetentionConfig) validateTimeTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, segmentsValidationAndRetentionConfigTypeTimeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SegmentsValidationAndRetentionConfig) validateTimeType(formats strfmt.Registry) error {
	if swag.IsZero(m.TimeType) { // not required
		return nil
	}

	// value enum
	if err := m.validateTimeTypeEnum("timeType", "body", m.TimeType); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this segments validation and retention config based on the context it is used
func (m *SegmentsValidationAndRetentionConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCompletionConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateReplicaGroupStrategyConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SegmentsValidationAndRetentionConfig) contextValidateCompletionConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.CompletionConfig != nil {
		if err := m.CompletionConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("completionConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("completionConfig")
			}
			return err
		}
	}

	return nil
}

func (m *SegmentsValidationAndRetentionConfig) contextValidateReplicaGroupStrategyConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.ReplicaGroupStrategyConfig != nil {
		if err := m.ReplicaGroupStrategyConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("replicaGroupStrategyConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("replicaGroupStrategyConfig")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SegmentsValidationAndRetentionConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SegmentsValidationAndRetentionConfig) UnmarshalBinary(b []byte) error {
	var res SegmentsValidationAndRetentionConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
