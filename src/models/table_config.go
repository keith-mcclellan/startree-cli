// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// TableConfig table config
//
// swagger:model TableConfig
type TableConfig struct {

	// dedup config
	DedupConfig *DedupConfig `json:"dedupConfig,omitempty"`

	// dimension table config
	DimensionTableConfig *DimensionTableConfig `json:"dimensionTableConfig,omitempty"`

	// field config list
	FieldConfigList []*FieldConfig `json:"fieldConfigList"`

	// ingestion config
	IngestionConfig *IngestionConfig `json:"ingestionConfig,omitempty"`

	// instance assignment config map
	InstanceAssignmentConfigMap map[string]InstanceAssignmentConfig `json:"instanceAssignmentConfigMap,omitempty"`

	// instance partitions map
	InstancePartitionsMap map[string]string `json:"instancePartitionsMap,omitempty"`

	// is dim table
	// Read Only: true
	IsDimTable *bool `json:"isDimTable,omitempty"`

	// metadata
	Metadata *TableCustomConfig `json:"metadata,omitempty"`

	// query
	Query *QueryConfig `json:"query,omitempty"`

	// quota
	Quota *QuotaConfig `json:"quota,omitempty"`

	// routing
	Routing *RoutingConfig `json:"routing,omitempty"`

	// segment assignment config map
	SegmentAssignmentConfigMap map[string]SegmentAssignmentConfig `json:"segmentAssignmentConfigMap,omitempty"`

	// segments config
	SegmentsConfig *SegmentsValidationAndRetentionConfig `json:"segmentsConfig,omitempty"`

	// table index config
	TableIndexConfig *IndexingConfig `json:"tableIndexConfig,omitempty"`

	// table name
	// Read Only: true
	TableName string `json:"tableName,omitempty"`

	// table type
	// Read Only: true
	// Enum: [OFFLINE REALTIME]
	TableType string `json:"tableType,omitempty"`

	// task
	Task *TableTaskConfig `json:"task,omitempty"`

	// tenants
	Tenants *TenantConfig `json:"tenants,omitempty"`

	// tier configs
	TierConfigs []*TierConfig `json:"tierConfigs"`

	// tuner configs
	TunerConfigs []*TunerConfig `json:"tunerConfigs"`

	// upsert config
	UpsertConfig *UpsertConfig `json:"upsertConfig,omitempty"`
}

// Validate validates this table config
func (m *TableConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDedupConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDimensionTableConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFieldConfigList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIngestionConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInstanceAssignmentConfigMap(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQuery(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQuota(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRouting(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSegmentAssignmentConfigMap(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSegmentsConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTableIndexConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTableType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTask(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTenants(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTierConfigs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTunerConfigs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpsertConfig(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TableConfig) validateDedupConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.DedupConfig) { // not required
		return nil
	}

	if m.DedupConfig != nil {
		if err := m.DedupConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dedupConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dedupConfig")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfig) validateDimensionTableConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.DimensionTableConfig) { // not required
		return nil
	}

	if m.DimensionTableConfig != nil {
		if err := m.DimensionTableConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dimensionTableConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dimensionTableConfig")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfig) validateFieldConfigList(formats strfmt.Registry) error {
	if swag.IsZero(m.FieldConfigList) { // not required
		return nil
	}

	for i := 0; i < len(m.FieldConfigList); i++ {
		if swag.IsZero(m.FieldConfigList[i]) { // not required
			continue
		}

		if m.FieldConfigList[i] != nil {
			if err := m.FieldConfigList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("fieldConfigList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("fieldConfigList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TableConfig) validateIngestionConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.IngestionConfig) { // not required
		return nil
	}

	if m.IngestionConfig != nil {
		if err := m.IngestionConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ingestionConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ingestionConfig")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfig) validateInstanceAssignmentConfigMap(formats strfmt.Registry) error {
	if swag.IsZero(m.InstanceAssignmentConfigMap) { // not required
		return nil
	}

	for k := range m.InstanceAssignmentConfigMap {

		if err := validate.Required("instanceAssignmentConfigMap"+"."+k, "body", m.InstanceAssignmentConfigMap[k]); err != nil {
			return err
		}
		if val, ok := m.InstanceAssignmentConfigMap[k]; ok {
			if err := val.Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("instanceAssignmentConfigMap" + "." + k)
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("instanceAssignmentConfigMap" + "." + k)
				}
				return err
			}
		}

	}

	return nil
}

func (m *TableConfig) validateMetadata(formats strfmt.Registry) error {
	if swag.IsZero(m.Metadata) { // not required
		return nil
	}

	if m.Metadata != nil {
		if err := m.Metadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("metadata")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfig) validateQuery(formats strfmt.Registry) error {
	if swag.IsZero(m.Query) { // not required
		return nil
	}

	if m.Query != nil {
		if err := m.Query.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("query")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("query")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfig) validateQuota(formats strfmt.Registry) error {
	if swag.IsZero(m.Quota) { // not required
		return nil
	}

	if m.Quota != nil {
		if err := m.Quota.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("quota")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("quota")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfig) validateRouting(formats strfmt.Registry) error {
	if swag.IsZero(m.Routing) { // not required
		return nil
	}

	if m.Routing != nil {
		if err := m.Routing.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("routing")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("routing")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfig) validateSegmentAssignmentConfigMap(formats strfmt.Registry) error {
	if swag.IsZero(m.SegmentAssignmentConfigMap) { // not required
		return nil
	}

	for k := range m.SegmentAssignmentConfigMap {

		if err := validate.Required("segmentAssignmentConfigMap"+"."+k, "body", m.SegmentAssignmentConfigMap[k]); err != nil {
			return err
		}
		if val, ok := m.SegmentAssignmentConfigMap[k]; ok {
			if err := val.Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("segmentAssignmentConfigMap" + "." + k)
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("segmentAssignmentConfigMap" + "." + k)
				}
				return err
			}
		}

	}

	return nil
}

func (m *TableConfig) validateSegmentsConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.SegmentsConfig) { // not required
		return nil
	}

	if m.SegmentsConfig != nil {
		if err := m.SegmentsConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("segmentsConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("segmentsConfig")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfig) validateTableIndexConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.TableIndexConfig) { // not required
		return nil
	}

	if m.TableIndexConfig != nil {
		if err := m.TableIndexConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tableIndexConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("tableIndexConfig")
			}
			return err
		}
	}

	return nil
}

var tableConfigTypeTableTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["OFFLINE","REALTIME"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		tableConfigTypeTableTypePropEnum = append(tableConfigTypeTableTypePropEnum, v)
	}
}

const (

	// TableConfigTableTypeOFFLINE captures enum value "OFFLINE"
	TableConfigTableTypeOFFLINE string = "OFFLINE"

	// TableConfigTableTypeREALTIME captures enum value "REALTIME"
	TableConfigTableTypeREALTIME string = "REALTIME"
)

// prop value enum
func (m *TableConfig) validateTableTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, tableConfigTypeTableTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TableConfig) validateTableType(formats strfmt.Registry) error {
	if swag.IsZero(m.TableType) { // not required
		return nil
	}

	// value enum
	if err := m.validateTableTypeEnum("tableType", "body", m.TableType); err != nil {
		return err
	}

	return nil
}

func (m *TableConfig) validateTask(formats strfmt.Registry) error {
	if swag.IsZero(m.Task) { // not required
		return nil
	}

	if m.Task != nil {
		if err := m.Task.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("task")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("task")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfig) validateTenants(formats strfmt.Registry) error {
	if swag.IsZero(m.Tenants) { // not required
		return nil
	}

	if m.Tenants != nil {
		if err := m.Tenants.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tenants")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("tenants")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfig) validateTierConfigs(formats strfmt.Registry) error {
	if swag.IsZero(m.TierConfigs) { // not required
		return nil
	}

	for i := 0; i < len(m.TierConfigs); i++ {
		if swag.IsZero(m.TierConfigs[i]) { // not required
			continue
		}

		if m.TierConfigs[i] != nil {
			if err := m.TierConfigs[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tierConfigs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("tierConfigs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TableConfig) validateTunerConfigs(formats strfmt.Registry) error {
	if swag.IsZero(m.TunerConfigs) { // not required
		return nil
	}

	for i := 0; i < len(m.TunerConfigs); i++ {
		if swag.IsZero(m.TunerConfigs[i]) { // not required
			continue
		}

		if m.TunerConfigs[i] != nil {
			if err := m.TunerConfigs[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tunerConfigs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("tunerConfigs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TableConfig) validateUpsertConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.UpsertConfig) { // not required
		return nil
	}

	if m.UpsertConfig != nil {
		if err := m.UpsertConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("upsertConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("upsertConfig")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this table config based on the context it is used
func (m *TableConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDedupConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDimensionTableConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFieldConfigList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIngestionConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateInstanceAssignmentConfigMap(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsDimTable(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateQuery(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateQuota(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRouting(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSegmentAssignmentConfigMap(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSegmentsConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTableIndexConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTableName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTableType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTask(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTenants(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTierConfigs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTunerConfigs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUpsertConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TableConfig) contextValidateDedupConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.DedupConfig != nil {
		if err := m.DedupConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dedupConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dedupConfig")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfig) contextValidateDimensionTableConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.DimensionTableConfig != nil {
		if err := m.DimensionTableConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dimensionTableConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dimensionTableConfig")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfig) contextValidateFieldConfigList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.FieldConfigList); i++ {

		if m.FieldConfigList[i] != nil {
			if err := m.FieldConfigList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("fieldConfigList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("fieldConfigList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TableConfig) contextValidateIngestionConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.IngestionConfig != nil {
		if err := m.IngestionConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ingestionConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ingestionConfig")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfig) contextValidateInstanceAssignmentConfigMap(ctx context.Context, formats strfmt.Registry) error {

	for k := range m.InstanceAssignmentConfigMap {

		if val, ok := m.InstanceAssignmentConfigMap[k]; ok {
			if err := val.ContextValidate(ctx, formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *TableConfig) contextValidateIsDimTable(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "isDimTable", "body", m.IsDimTable); err != nil {
		return err
	}

	return nil
}

func (m *TableConfig) contextValidateMetadata(ctx context.Context, formats strfmt.Registry) error {

	if m.Metadata != nil {
		if err := m.Metadata.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("metadata")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfig) contextValidateQuery(ctx context.Context, formats strfmt.Registry) error {

	if m.Query != nil {
		if err := m.Query.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("query")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("query")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfig) contextValidateQuota(ctx context.Context, formats strfmt.Registry) error {

	if m.Quota != nil {
		if err := m.Quota.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("quota")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("quota")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfig) contextValidateRouting(ctx context.Context, formats strfmt.Registry) error {

	if m.Routing != nil {
		if err := m.Routing.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("routing")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("routing")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfig) contextValidateSegmentAssignmentConfigMap(ctx context.Context, formats strfmt.Registry) error {

	for k := range m.SegmentAssignmentConfigMap {

		if val, ok := m.SegmentAssignmentConfigMap[k]; ok {
			if err := val.ContextValidate(ctx, formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *TableConfig) contextValidateSegmentsConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.SegmentsConfig != nil {
		if err := m.SegmentsConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("segmentsConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("segmentsConfig")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfig) contextValidateTableIndexConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.TableIndexConfig != nil {
		if err := m.TableIndexConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tableIndexConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("tableIndexConfig")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfig) contextValidateTableName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "tableName", "body", string(m.TableName)); err != nil {
		return err
	}

	return nil
}

func (m *TableConfig) contextValidateTableType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "tableType", "body", string(m.TableType)); err != nil {
		return err
	}

	return nil
}

func (m *TableConfig) contextValidateTask(ctx context.Context, formats strfmt.Registry) error {

	if m.Task != nil {
		if err := m.Task.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("task")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("task")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfig) contextValidateTenants(ctx context.Context, formats strfmt.Registry) error {

	if m.Tenants != nil {
		if err := m.Tenants.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tenants")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("tenants")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfig) contextValidateTierConfigs(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.TierConfigs); i++ {

		if m.TierConfigs[i] != nil {
			if err := m.TierConfigs[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tierConfigs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("tierConfigs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TableConfig) contextValidateTunerConfigs(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.TunerConfigs); i++ {

		if m.TunerConfigs[i] != nil {
			if err := m.TunerConfigs[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tunerConfigs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("tunerConfigs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TableConfig) contextValidateUpsertConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.UpsertConfig != nil {
		if err := m.UpsertConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("upsertConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("upsertConfig")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TableConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TableConfig) UnmarshalBinary(b []byte) error {
	var res TableConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
