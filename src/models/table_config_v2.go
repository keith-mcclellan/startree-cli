// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// TableConfigV2 table config v2
//
// swagger:model TableConfigV2
type TableConfigV2 struct {

	// offline
	Offline *TableConfigV2Offline `json:"offline,omitempty"`

	// realtime
	Realtime *TableConfigV2Realtime `json:"realtime,omitempty"`

	// schema
	// Required: true
	Schema *TableConfigV2Schema `json:"schema"`

	// table name
	// Required: true
	TableName *string `json:"tableName"`
}

// Validate validates this table config v2
func (m *TableConfigV2) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateOffline(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRealtime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSchema(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTableName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TableConfigV2) validateOffline(formats strfmt.Registry) error {
	if swag.IsZero(m.Offline) { // not required
		return nil
	}

	if m.Offline != nil {
		if err := m.Offline.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("offline")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("offline")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfigV2) validateRealtime(formats strfmt.Registry) error {
	if swag.IsZero(m.Realtime) { // not required
		return nil
	}

	if m.Realtime != nil {
		if err := m.Realtime.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("realtime")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("realtime")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfigV2) validateSchema(formats strfmt.Registry) error {

	if err := validate.Required("schema", "body", m.Schema); err != nil {
		return err
	}

	if m.Schema != nil {
		if err := m.Schema.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("schema")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("schema")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfigV2) validateTableName(formats strfmt.Registry) error {

	if err := validate.Required("tableName", "body", m.TableName); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this table config v2 based on the context it is used
func (m *TableConfigV2) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateOffline(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRealtime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSchema(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TableConfigV2) contextValidateOffline(ctx context.Context, formats strfmt.Registry) error {

	if m.Offline != nil {
		if err := m.Offline.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("offline")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("offline")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfigV2) contextValidateRealtime(ctx context.Context, formats strfmt.Registry) error {

	if m.Realtime != nil {
		if err := m.Realtime.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("realtime")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("realtime")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfigV2) contextValidateSchema(ctx context.Context, formats strfmt.Registry) error {

	if m.Schema != nil {
		if err := m.Schema.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("schema")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("schema")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TableConfigV2) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TableConfigV2) UnmarshalBinary(b []byte) error {
	var res TableConfigV2
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TableConfigV2Offline table config v2 offline
//
// swagger:model TableConfigV2Offline
type TableConfigV2Offline struct {

	// ingestion config
	// Required: true
	IngestionConfig *TableConfigV2OfflineIngestionConfig `json:"ingestionConfig"`

	// is dim table
	// Required: true
	IsDimTable *bool `json:"isDimTable"`

	// metadata
	// Required: true
	Metadata interface{} `json:"metadata"`

	// segments config
	// Required: true
	SegmentsConfig *TableConfigV2OfflineSegmentsConfig `json:"segmentsConfig"`

	// table index config
	// Required: true
	TableIndexConfig *TableConfigV2OfflineTableIndexConfig `json:"tableIndexConfig"`

	// table name
	// Required: true
	TableName *string `json:"tableName"`

	// table type
	// Required: true
	TableType *string `json:"tableType"`

	// task
	// Required: true
	Task *TableConfigV2OfflineTask `json:"task"`

	// tenants
	// Required: true
	Tenants *TableConfigV2OfflineTenants `json:"tenants"`
}

// Validate validates this table config v2 offline
func (m *TableConfigV2Offline) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIngestionConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsDimTable(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSegmentsConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTableIndexConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTableName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTableType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTask(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTenants(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TableConfigV2Offline) validateIngestionConfig(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"ingestionConfig", "body", m.IngestionConfig); err != nil {
		return err
	}

	if m.IngestionConfig != nil {
		if err := m.IngestionConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("offline" + "." + "ingestionConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("offline" + "." + "ingestionConfig")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfigV2Offline) validateIsDimTable(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"isDimTable", "body", m.IsDimTable); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2Offline) validateMetadata(formats strfmt.Registry) error {

	if m.Metadata == nil {
		return errors.Required("offline"+"."+"metadata", "body", nil)
	}

	return nil
}

func (m *TableConfigV2Offline) validateSegmentsConfig(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"segmentsConfig", "body", m.SegmentsConfig); err != nil {
		return err
	}

	if m.SegmentsConfig != nil {
		if err := m.SegmentsConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("offline" + "." + "segmentsConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("offline" + "." + "segmentsConfig")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfigV2Offline) validateTableIndexConfig(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"tableIndexConfig", "body", m.TableIndexConfig); err != nil {
		return err
	}

	if m.TableIndexConfig != nil {
		if err := m.TableIndexConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("offline" + "." + "tableIndexConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("offline" + "." + "tableIndexConfig")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfigV2Offline) validateTableName(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"tableName", "body", m.TableName); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2Offline) validateTableType(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"tableType", "body", m.TableType); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2Offline) validateTask(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"task", "body", m.Task); err != nil {
		return err
	}

	if m.Task != nil {
		if err := m.Task.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("offline" + "." + "task")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("offline" + "." + "task")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfigV2Offline) validateTenants(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"tenants", "body", m.Tenants); err != nil {
		return err
	}

	if m.Tenants != nil {
		if err := m.Tenants.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("offline" + "." + "tenants")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("offline" + "." + "tenants")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this table config v2 offline based on the context it is used
func (m *TableConfigV2Offline) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIngestionConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSegmentsConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTableIndexConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTask(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTenants(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TableConfigV2Offline) contextValidateIngestionConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.IngestionConfig != nil {
		if err := m.IngestionConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("offline" + "." + "ingestionConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("offline" + "." + "ingestionConfig")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfigV2Offline) contextValidateSegmentsConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.SegmentsConfig != nil {
		if err := m.SegmentsConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("offline" + "." + "segmentsConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("offline" + "." + "segmentsConfig")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfigV2Offline) contextValidateTableIndexConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.TableIndexConfig != nil {
		if err := m.TableIndexConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("offline" + "." + "tableIndexConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("offline" + "." + "tableIndexConfig")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfigV2Offline) contextValidateTask(ctx context.Context, formats strfmt.Registry) error {

	if m.Task != nil {
		if err := m.Task.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("offline" + "." + "task")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("offline" + "." + "task")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfigV2Offline) contextValidateTenants(ctx context.Context, formats strfmt.Registry) error {

	if m.Tenants != nil {
		if err := m.Tenants.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("offline" + "." + "tenants")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("offline" + "." + "tenants")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TableConfigV2Offline) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TableConfigV2Offline) UnmarshalBinary(b []byte) error {
	var res TableConfigV2Offline
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TableConfigV2OfflineIngestionConfig table config v2 offline ingestion config
//
// swagger:model TableConfigV2OfflineIngestionConfig
type TableConfigV2OfflineIngestionConfig struct {

	// batch ingestion config
	// Required: true
	BatchIngestionConfig *TableConfigV2OfflineIngestionConfigBatchIngestionConfig `json:"batchIngestionConfig"`

	// continue on error
	// Required: true
	ContinueOnError *bool `json:"continueOnError"`

	// row time value check
	// Required: true
	RowTimeValueCheck *bool `json:"rowTimeValueCheck"`

	// segment time value check
	// Required: true
	SegmentTimeValueCheck *bool `json:"segmentTimeValueCheck"`

	// transform configs
	// Required: true
	TransformConfigs []interface{} `json:"transformConfigs"`
}

// Validate validates this table config v2 offline ingestion config
func (m *TableConfigV2OfflineIngestionConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBatchIngestionConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateContinueOnError(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRowTimeValueCheck(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSegmentTimeValueCheck(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransformConfigs(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TableConfigV2OfflineIngestionConfig) validateBatchIngestionConfig(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"ingestionConfig"+"."+"batchIngestionConfig", "body", m.BatchIngestionConfig); err != nil {
		return err
	}

	if m.BatchIngestionConfig != nil {
		if err := m.BatchIngestionConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("offline" + "." + "ingestionConfig" + "." + "batchIngestionConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("offline" + "." + "ingestionConfig" + "." + "batchIngestionConfig")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfigV2OfflineIngestionConfig) validateContinueOnError(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"ingestionConfig"+"."+"continueOnError", "body", m.ContinueOnError); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2OfflineIngestionConfig) validateRowTimeValueCheck(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"ingestionConfig"+"."+"rowTimeValueCheck", "body", m.RowTimeValueCheck); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2OfflineIngestionConfig) validateSegmentTimeValueCheck(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"ingestionConfig"+"."+"segmentTimeValueCheck", "body", m.SegmentTimeValueCheck); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2OfflineIngestionConfig) validateTransformConfigs(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"ingestionConfig"+"."+"transformConfigs", "body", m.TransformConfigs); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this table config v2 offline ingestion config based on the context it is used
func (m *TableConfigV2OfflineIngestionConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBatchIngestionConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TableConfigV2OfflineIngestionConfig) contextValidateBatchIngestionConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.BatchIngestionConfig != nil {
		if err := m.BatchIngestionConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("offline" + "." + "ingestionConfig" + "." + "batchIngestionConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("offline" + "." + "ingestionConfig" + "." + "batchIngestionConfig")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TableConfigV2OfflineIngestionConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TableConfigV2OfflineIngestionConfig) UnmarshalBinary(b []byte) error {
	var res TableConfigV2OfflineIngestionConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TableConfigV2OfflineIngestionConfigBatchIngestionConfig table config v2 offline ingestion config batch ingestion config
//
// swagger:model TableConfigV2OfflineIngestionConfigBatchIngestionConfig
type TableConfigV2OfflineIngestionConfigBatchIngestionConfig struct {

	// consistent data push
	// Required: true
	ConsistentDataPush *bool `json:"consistentDataPush"`

	// segment ingestion type
	// Required: true
	SegmentIngestionType *string `json:"segmentIngestionType"`
}

// Validate validates this table config v2 offline ingestion config batch ingestion config
func (m *TableConfigV2OfflineIngestionConfigBatchIngestionConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateConsistentDataPush(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSegmentIngestionType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TableConfigV2OfflineIngestionConfigBatchIngestionConfig) validateConsistentDataPush(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"ingestionConfig"+"."+"batchIngestionConfig"+"."+"consistentDataPush", "body", m.ConsistentDataPush); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2OfflineIngestionConfigBatchIngestionConfig) validateSegmentIngestionType(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"ingestionConfig"+"."+"batchIngestionConfig"+"."+"segmentIngestionType", "body", m.SegmentIngestionType); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this table config v2 offline ingestion config batch ingestion config based on context it is used
func (m *TableConfigV2OfflineIngestionConfigBatchIngestionConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TableConfigV2OfflineIngestionConfigBatchIngestionConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TableConfigV2OfflineIngestionConfigBatchIngestionConfig) UnmarshalBinary(b []byte) error {
	var res TableConfigV2OfflineIngestionConfigBatchIngestionConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TableConfigV2OfflineSegmentsConfig table config v2 offline segments config
//
// swagger:model TableConfigV2OfflineSegmentsConfig
type TableConfigV2OfflineSegmentsConfig struct {

	// deleted segments retention period
	// Required: true
	DeletedSegmentsRetentionPeriod *string `json:"deletedSegmentsRetentionPeriod"`

	// minimize data movement
	// Required: true
	MinimizeDataMovement *bool `json:"minimizeDataMovement"`

	// replication
	// Required: true
	Replication *string `json:"replication"`

	// retention time unit
	// Required: true
	RetentionTimeUnit *string `json:"retentionTimeUnit"`

	// retention time value
	// Required: true
	RetentionTimeValue *string `json:"retentionTimeValue"`

	// schema name
	// Required: true
	SchemaName *string `json:"schemaName"`

	// segment assignment strategy
	// Required: true
	SegmentAssignmentStrategy *string `json:"segmentAssignmentStrategy"`

	// segment push type
	// Required: true
	SegmentPushType *string `json:"segmentPushType"`

	// time column name
	// Required: true
	TimeColumnName *string `json:"timeColumnName"`
}

// Validate validates this table config v2 offline segments config
func (m *TableConfigV2OfflineSegmentsConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDeletedSegmentsRetentionPeriod(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMinimizeDataMovement(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReplication(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRetentionTimeUnit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRetentionTimeValue(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSchemaName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSegmentAssignmentStrategy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSegmentPushType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimeColumnName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TableConfigV2OfflineSegmentsConfig) validateDeletedSegmentsRetentionPeriod(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"segmentsConfig"+"."+"deletedSegmentsRetentionPeriod", "body", m.DeletedSegmentsRetentionPeriod); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2OfflineSegmentsConfig) validateMinimizeDataMovement(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"segmentsConfig"+"."+"minimizeDataMovement", "body", m.MinimizeDataMovement); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2OfflineSegmentsConfig) validateReplication(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"segmentsConfig"+"."+"replication", "body", m.Replication); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2OfflineSegmentsConfig) validateRetentionTimeUnit(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"segmentsConfig"+"."+"retentionTimeUnit", "body", m.RetentionTimeUnit); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2OfflineSegmentsConfig) validateRetentionTimeValue(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"segmentsConfig"+"."+"retentionTimeValue", "body", m.RetentionTimeValue); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2OfflineSegmentsConfig) validateSchemaName(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"segmentsConfig"+"."+"schemaName", "body", m.SchemaName); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2OfflineSegmentsConfig) validateSegmentAssignmentStrategy(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"segmentsConfig"+"."+"segmentAssignmentStrategy", "body", m.SegmentAssignmentStrategy); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2OfflineSegmentsConfig) validateSegmentPushType(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"segmentsConfig"+"."+"segmentPushType", "body", m.SegmentPushType); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2OfflineSegmentsConfig) validateTimeColumnName(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"segmentsConfig"+"."+"timeColumnName", "body", m.TimeColumnName); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this table config v2 offline segments config based on context it is used
func (m *TableConfigV2OfflineSegmentsConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TableConfigV2OfflineSegmentsConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TableConfigV2OfflineSegmentsConfig) UnmarshalBinary(b []byte) error {
	var res TableConfigV2OfflineSegmentsConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TableConfigV2OfflineTableIndexConfig table config v2 offline table index config
//
// swagger:model TableConfigV2OfflineTableIndexConfig
type TableConfigV2OfflineTableIndexConfig struct {

	// aggregate metrics
	// Required: true
	AggregateMetrics *bool `json:"aggregateMetrics"`

	// auto generated inverted index
	// Required: true
	AutoGeneratedInvertedIndex *bool `json:"autoGeneratedInvertedIndex"`

	// create inverted index during segment generation
	// Required: true
	CreateInvertedIndexDuringSegmentGeneration *bool `json:"createInvertedIndexDuringSegmentGeneration"`

	// enable default star tree
	// Required: true
	EnableDefaultStarTree *bool `json:"enableDefaultStarTree"`

	// enable dynamic star tree creation
	// Required: true
	EnableDynamicStarTreeCreation *bool `json:"enableDynamicStarTreeCreation"`

	// inverted index columns
	// Required: true
	InvertedIndexColumns []interface{} `json:"invertedIndexColumns"`

	// load mode
	// Required: true
	LoadMode *string `json:"loadMode"`

	// no dictionary columns
	// Required: true
	NoDictionaryColumns []interface{} `json:"noDictionaryColumns"`

	// no dictionary size ratio threshold
	// Required: true
	NoDictionarySizeRatioThreshold *float64 `json:"noDictionarySizeRatioThreshold"`

	// null handling enabled
	// Required: true
	NullHandlingEnabled *bool `json:"nullHandlingEnabled"`

	// optimize dictionary
	// Required: true
	OptimizeDictionary *bool `json:"optimizeDictionary"`

	// optimize dictionary for metrics
	// Required: true
	OptimizeDictionaryForMetrics *bool `json:"optimizeDictionaryForMetrics"`

	// range index version
	// Required: true
	RangeIndexVersion *int64 `json:"rangeIndexVersion"`

	// var length dictionary columns
	// Required: true
	VarLengthDictionaryColumns []interface{} `json:"varLengthDictionaryColumns"`
}

// Validate validates this table config v2 offline table index config
func (m *TableConfigV2OfflineTableIndexConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAggregateMetrics(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAutoGeneratedInvertedIndex(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreateInvertedIndexDuringSegmentGeneration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEnableDefaultStarTree(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEnableDynamicStarTreeCreation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInvertedIndexColumns(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLoadMode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNoDictionaryColumns(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNoDictionarySizeRatioThreshold(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNullHandlingEnabled(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOptimizeDictionary(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOptimizeDictionaryForMetrics(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRangeIndexVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVarLengthDictionaryColumns(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TableConfigV2OfflineTableIndexConfig) validateAggregateMetrics(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"tableIndexConfig"+"."+"aggregateMetrics", "body", m.AggregateMetrics); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2OfflineTableIndexConfig) validateAutoGeneratedInvertedIndex(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"tableIndexConfig"+"."+"autoGeneratedInvertedIndex", "body", m.AutoGeneratedInvertedIndex); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2OfflineTableIndexConfig) validateCreateInvertedIndexDuringSegmentGeneration(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"tableIndexConfig"+"."+"createInvertedIndexDuringSegmentGeneration", "body", m.CreateInvertedIndexDuringSegmentGeneration); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2OfflineTableIndexConfig) validateEnableDefaultStarTree(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"tableIndexConfig"+"."+"enableDefaultStarTree", "body", m.EnableDefaultStarTree); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2OfflineTableIndexConfig) validateEnableDynamicStarTreeCreation(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"tableIndexConfig"+"."+"enableDynamicStarTreeCreation", "body", m.EnableDynamicStarTreeCreation); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2OfflineTableIndexConfig) validateInvertedIndexColumns(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"tableIndexConfig"+"."+"invertedIndexColumns", "body", m.InvertedIndexColumns); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2OfflineTableIndexConfig) validateLoadMode(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"tableIndexConfig"+"."+"loadMode", "body", m.LoadMode); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2OfflineTableIndexConfig) validateNoDictionaryColumns(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"tableIndexConfig"+"."+"noDictionaryColumns", "body", m.NoDictionaryColumns); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2OfflineTableIndexConfig) validateNoDictionarySizeRatioThreshold(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"tableIndexConfig"+"."+"noDictionarySizeRatioThreshold", "body", m.NoDictionarySizeRatioThreshold); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2OfflineTableIndexConfig) validateNullHandlingEnabled(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"tableIndexConfig"+"."+"nullHandlingEnabled", "body", m.NullHandlingEnabled); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2OfflineTableIndexConfig) validateOptimizeDictionary(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"tableIndexConfig"+"."+"optimizeDictionary", "body", m.OptimizeDictionary); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2OfflineTableIndexConfig) validateOptimizeDictionaryForMetrics(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"tableIndexConfig"+"."+"optimizeDictionaryForMetrics", "body", m.OptimizeDictionaryForMetrics); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2OfflineTableIndexConfig) validateRangeIndexVersion(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"tableIndexConfig"+"."+"rangeIndexVersion", "body", m.RangeIndexVersion); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2OfflineTableIndexConfig) validateVarLengthDictionaryColumns(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"tableIndexConfig"+"."+"varLengthDictionaryColumns", "body", m.VarLengthDictionaryColumns); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this table config v2 offline table index config based on context it is used
func (m *TableConfigV2OfflineTableIndexConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TableConfigV2OfflineTableIndexConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TableConfigV2OfflineTableIndexConfig) UnmarshalBinary(b []byte) error {
	var res TableConfigV2OfflineTableIndexConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TableConfigV2OfflineTask table config v2 offline task
//
// swagger:model TableConfigV2OfflineTask
type TableConfigV2OfflineTask struct {

	// task type configs map
	// Required: true
	TaskTypeConfigsMap *TableConfigV2OfflineTaskTaskTypeConfigsMap `json:"taskTypeConfigsMap"`
}

// Validate validates this table config v2 offline task
func (m *TableConfigV2OfflineTask) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTaskTypeConfigsMap(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TableConfigV2OfflineTask) validateTaskTypeConfigsMap(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"task"+"."+"taskTypeConfigsMap", "body", m.TaskTypeConfigsMap); err != nil {
		return err
	}

	if m.TaskTypeConfigsMap != nil {
		if err := m.TaskTypeConfigsMap.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("offline" + "." + "task" + "." + "taskTypeConfigsMap")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("offline" + "." + "task" + "." + "taskTypeConfigsMap")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this table config v2 offline task based on the context it is used
func (m *TableConfigV2OfflineTask) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateTaskTypeConfigsMap(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TableConfigV2OfflineTask) contextValidateTaskTypeConfigsMap(ctx context.Context, formats strfmt.Registry) error {

	if m.TaskTypeConfigsMap != nil {
		if err := m.TaskTypeConfigsMap.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("offline" + "." + "task" + "." + "taskTypeConfigsMap")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("offline" + "." + "task" + "." + "taskTypeConfigsMap")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TableConfigV2OfflineTask) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TableConfigV2OfflineTask) UnmarshalBinary(b []byte) error {
	var res TableConfigV2OfflineTask
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TableConfigV2OfflineTaskTaskTypeConfigsMap table config v2 offline task task type configs map
//
// swagger:model TableConfigV2OfflineTaskTaskTypeConfigsMap
type TableConfigV2OfflineTaskTaskTypeConfigsMap struct {

	// file ingestion task
	// Required: true
	FileIngestionTask *TableConfigV2OfflineTaskTaskTypeConfigsMapFileIngestionTask `json:"FileIngestionTask"`
}

// Validate validates this table config v2 offline task task type configs map
func (m *TableConfigV2OfflineTaskTaskTypeConfigsMap) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFileIngestionTask(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TableConfigV2OfflineTaskTaskTypeConfigsMap) validateFileIngestionTask(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"task"+"."+"taskTypeConfigsMap"+"."+"FileIngestionTask", "body", m.FileIngestionTask); err != nil {
		return err
	}

	if m.FileIngestionTask != nil {
		if err := m.FileIngestionTask.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("offline" + "." + "task" + "." + "taskTypeConfigsMap" + "." + "FileIngestionTask")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("offline" + "." + "task" + "." + "taskTypeConfigsMap" + "." + "FileIngestionTask")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this table config v2 offline task task type configs map based on the context it is used
func (m *TableConfigV2OfflineTaskTaskTypeConfigsMap) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateFileIngestionTask(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TableConfigV2OfflineTaskTaskTypeConfigsMap) contextValidateFileIngestionTask(ctx context.Context, formats strfmt.Registry) error {

	if m.FileIngestionTask != nil {
		if err := m.FileIngestionTask.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("offline" + "." + "task" + "." + "taskTypeConfigsMap" + "." + "FileIngestionTask")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("offline" + "." + "task" + "." + "taskTypeConfigsMap" + "." + "FileIngestionTask")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TableConfigV2OfflineTaskTaskTypeConfigsMap) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TableConfigV2OfflineTaskTaskTypeConfigsMap) UnmarshalBinary(b []byte) error {
	var res TableConfigV2OfflineTaskTaskTypeConfigsMap
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TableConfigV2OfflineTaskTaskTypeConfigsMapFileIngestionTask table config v2 offline task task type configs map file ingestion task
//
// swagger:model TableConfigV2OfflineTaskTaskTypeConfigsMapFileIngestionTask
type TableConfigV2OfflineTaskTaskTypeConfigsMapFileIngestionTask struct {

	// input fs class name
	// Required: true
	InputFsClassName *string `json:"input.fs.className"`

	// input fs prop access key
	// Required: true
	InputFsPropAccessKey *string `json:"input.fs.prop.accessKey"`

	// input fs prop region
	// Required: true
	InputFsPropRegion *string `json:"input.fs.prop.region"`

	// input fs prop secret key
	// Required: true
	InputFsPropSecretKey *string `json:"input.fs.prop.secretKey"`

	// input dir URI
	// Required: true
	InputDirURI *string `json:"inputDirURI"`

	// input format
	// Required: true
	InputFormat *string `json:"inputFormat"`

	// schedule
	// Required: true
	Schedule *string `json:"schedule"`

	// table max num tasks
	// Required: true
	TableMaxNumTasks *string `json:"tableMaxNumTasks"`

	// task max data size
	// Required: true
	TaskMaxDataSize *string `json:"taskMaxDataSize"`
}

// Validate validates this table config v2 offline task task type configs map file ingestion task
func (m *TableConfigV2OfflineTaskTaskTypeConfigsMapFileIngestionTask) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateInputFsClassName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInputFsPropAccessKey(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInputFsPropRegion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInputFsPropSecretKey(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInputDirURI(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInputFormat(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSchedule(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTableMaxNumTasks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTaskMaxDataSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TableConfigV2OfflineTaskTaskTypeConfigsMapFileIngestionTask) validateInputFsClassName(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"task"+"."+"taskTypeConfigsMap"+"."+"FileIngestionTask"+"."+"input.fs.className", "body", m.InputFsClassName); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2OfflineTaskTaskTypeConfigsMapFileIngestionTask) validateInputFsPropAccessKey(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"task"+"."+"taskTypeConfigsMap"+"."+"FileIngestionTask"+"."+"input.fs.prop.accessKey", "body", m.InputFsPropAccessKey); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2OfflineTaskTaskTypeConfigsMapFileIngestionTask) validateInputFsPropRegion(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"task"+"."+"taskTypeConfigsMap"+"."+"FileIngestionTask"+"."+"input.fs.prop.region", "body", m.InputFsPropRegion); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2OfflineTaskTaskTypeConfigsMapFileIngestionTask) validateInputFsPropSecretKey(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"task"+"."+"taskTypeConfigsMap"+"."+"FileIngestionTask"+"."+"input.fs.prop.secretKey", "body", m.InputFsPropSecretKey); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2OfflineTaskTaskTypeConfigsMapFileIngestionTask) validateInputDirURI(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"task"+"."+"taskTypeConfigsMap"+"."+"FileIngestionTask"+"."+"inputDirURI", "body", m.InputDirURI); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2OfflineTaskTaskTypeConfigsMapFileIngestionTask) validateInputFormat(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"task"+"."+"taskTypeConfigsMap"+"."+"FileIngestionTask"+"."+"inputFormat", "body", m.InputFormat); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2OfflineTaskTaskTypeConfigsMapFileIngestionTask) validateSchedule(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"task"+"."+"taskTypeConfigsMap"+"."+"FileIngestionTask"+"."+"schedule", "body", m.Schedule); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2OfflineTaskTaskTypeConfigsMapFileIngestionTask) validateTableMaxNumTasks(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"task"+"."+"taskTypeConfigsMap"+"."+"FileIngestionTask"+"."+"tableMaxNumTasks", "body", m.TableMaxNumTasks); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2OfflineTaskTaskTypeConfigsMapFileIngestionTask) validateTaskMaxDataSize(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"task"+"."+"taskTypeConfigsMap"+"."+"FileIngestionTask"+"."+"taskMaxDataSize", "body", m.TaskMaxDataSize); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this table config v2 offline task task type configs map file ingestion task based on context it is used
func (m *TableConfigV2OfflineTaskTaskTypeConfigsMapFileIngestionTask) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TableConfigV2OfflineTaskTaskTypeConfigsMapFileIngestionTask) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TableConfigV2OfflineTaskTaskTypeConfigsMapFileIngestionTask) UnmarshalBinary(b []byte) error {
	var res TableConfigV2OfflineTaskTaskTypeConfigsMapFileIngestionTask
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TableConfigV2OfflineTenants table config v2 offline tenants
//
// swagger:model TableConfigV2OfflineTenants
type TableConfigV2OfflineTenants struct {

	// broker
	// Required: true
	Broker *string `json:"broker"`

	// server
	// Required: true
	Server *string `json:"server"`
}

// Validate validates this table config v2 offline tenants
func (m *TableConfigV2OfflineTenants) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBroker(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServer(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TableConfigV2OfflineTenants) validateBroker(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"tenants"+"."+"broker", "body", m.Broker); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2OfflineTenants) validateServer(formats strfmt.Registry) error {

	if err := validate.Required("offline"+"."+"tenants"+"."+"server", "body", m.Server); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this table config v2 offline tenants based on context it is used
func (m *TableConfigV2OfflineTenants) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TableConfigV2OfflineTenants) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TableConfigV2OfflineTenants) UnmarshalBinary(b []byte) error {
	var res TableConfigV2OfflineTenants
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TableConfigV2Realtime table config v2 realtime
//
// swagger:model TableConfigV2Realtime
type TableConfigV2Realtime struct {

	// ingestion config
	// Required: true
	IngestionConfig *TableConfigV2RealtimeIngestionConfig `json:"ingestionConfig"`

	// is dim table
	// Required: true
	IsDimTable *bool `json:"isDimTable"`

	// metadata
	// Required: true
	Metadata interface{} `json:"metadata"`

	// routing
	// Required: true
	Routing *TableConfigV2RealtimeRouting `json:"routing"`

	// segments config
	// Required: true
	SegmentsConfig *TableConfigV2RealtimeSegmentsConfig `json:"segmentsConfig"`

	// table index config
	// Required: true
	TableIndexConfig *TableConfigV2RealtimeTableIndexConfig `json:"tableIndexConfig"`

	// table name
	// Required: true
	TableName *string `json:"tableName"`

	// table type
	// Required: true
	TableType *string `json:"tableType"`

	// tenants
	// Required: true
	Tenants *TableConfigV2RealtimeTenants `json:"tenants"`

	// upsert config
	// Required: true
	UpsertConfig *TableConfigV2RealtimeUpsertConfig `json:"upsertConfig"`
}

// Validate validates this table config v2 realtime
func (m *TableConfigV2Realtime) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIngestionConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsDimTable(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRouting(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSegmentsConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTableIndexConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTableName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTableType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTenants(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpsertConfig(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TableConfigV2Realtime) validateIngestionConfig(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"ingestionConfig", "body", m.IngestionConfig); err != nil {
		return err
	}

	if m.IngestionConfig != nil {
		if err := m.IngestionConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("realtime" + "." + "ingestionConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("realtime" + "." + "ingestionConfig")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfigV2Realtime) validateIsDimTable(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"isDimTable", "body", m.IsDimTable); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2Realtime) validateMetadata(formats strfmt.Registry) error {

	if m.Metadata == nil {
		return errors.Required("realtime"+"."+"metadata", "body", nil)
	}

	return nil
}

func (m *TableConfigV2Realtime) validateRouting(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"routing", "body", m.Routing); err != nil {
		return err
	}

	if m.Routing != nil {
		if err := m.Routing.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("realtime" + "." + "routing")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("realtime" + "." + "routing")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfigV2Realtime) validateSegmentsConfig(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"segmentsConfig", "body", m.SegmentsConfig); err != nil {
		return err
	}

	if m.SegmentsConfig != nil {
		if err := m.SegmentsConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("realtime" + "." + "segmentsConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("realtime" + "." + "segmentsConfig")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfigV2Realtime) validateTableIndexConfig(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"tableIndexConfig", "body", m.TableIndexConfig); err != nil {
		return err
	}

	if m.TableIndexConfig != nil {
		if err := m.TableIndexConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("realtime" + "." + "tableIndexConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("realtime" + "." + "tableIndexConfig")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfigV2Realtime) validateTableName(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"tableName", "body", m.TableName); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2Realtime) validateTableType(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"tableType", "body", m.TableType); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2Realtime) validateTenants(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"tenants", "body", m.Tenants); err != nil {
		return err
	}

	if m.Tenants != nil {
		if err := m.Tenants.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("realtime" + "." + "tenants")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("realtime" + "." + "tenants")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfigV2Realtime) validateUpsertConfig(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"upsertConfig", "body", m.UpsertConfig); err != nil {
		return err
	}

	if m.UpsertConfig != nil {
		if err := m.UpsertConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("realtime" + "." + "upsertConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("realtime" + "." + "upsertConfig")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this table config v2 realtime based on the context it is used
func (m *TableConfigV2Realtime) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIngestionConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRouting(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSegmentsConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTableIndexConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTenants(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUpsertConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TableConfigV2Realtime) contextValidateIngestionConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.IngestionConfig != nil {
		if err := m.IngestionConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("realtime" + "." + "ingestionConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("realtime" + "." + "ingestionConfig")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfigV2Realtime) contextValidateRouting(ctx context.Context, formats strfmt.Registry) error {

	if m.Routing != nil {
		if err := m.Routing.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("realtime" + "." + "routing")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("realtime" + "." + "routing")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfigV2Realtime) contextValidateSegmentsConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.SegmentsConfig != nil {
		if err := m.SegmentsConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("realtime" + "." + "segmentsConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("realtime" + "." + "segmentsConfig")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfigV2Realtime) contextValidateTableIndexConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.TableIndexConfig != nil {
		if err := m.TableIndexConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("realtime" + "." + "tableIndexConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("realtime" + "." + "tableIndexConfig")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfigV2Realtime) contextValidateTenants(ctx context.Context, formats strfmt.Registry) error {

	if m.Tenants != nil {
		if err := m.Tenants.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("realtime" + "." + "tenants")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("realtime" + "." + "tenants")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfigV2Realtime) contextValidateUpsertConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.UpsertConfig != nil {
		if err := m.UpsertConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("realtime" + "." + "upsertConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("realtime" + "." + "upsertConfig")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TableConfigV2Realtime) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TableConfigV2Realtime) UnmarshalBinary(b []byte) error {
	var res TableConfigV2Realtime
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TableConfigV2RealtimeIngestionConfig table config v2 realtime ingestion config
//
// swagger:model TableConfigV2RealtimeIngestionConfig
type TableConfigV2RealtimeIngestionConfig struct {

	// continue on error
	// Required: true
	ContinueOnError *bool `json:"continueOnError"`

	// row time value check
	// Required: true
	RowTimeValueCheck *bool `json:"rowTimeValueCheck"`

	// segment time value check
	// Required: true
	SegmentTimeValueCheck *bool `json:"segmentTimeValueCheck"`

	// stream ingestion config
	// Required: true
	StreamIngestionConfig *TableConfigV2RealtimeIngestionConfigStreamIngestionConfig `json:"streamIngestionConfig"`

	// transform configs
	// Required: true
	TransformConfigs []interface{} `json:"transformConfigs"`
}

// Validate validates this table config v2 realtime ingestion config
func (m *TableConfigV2RealtimeIngestionConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateContinueOnError(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRowTimeValueCheck(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSegmentTimeValueCheck(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStreamIngestionConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransformConfigs(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TableConfigV2RealtimeIngestionConfig) validateContinueOnError(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"ingestionConfig"+"."+"continueOnError", "body", m.ContinueOnError); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2RealtimeIngestionConfig) validateRowTimeValueCheck(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"ingestionConfig"+"."+"rowTimeValueCheck", "body", m.RowTimeValueCheck); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2RealtimeIngestionConfig) validateSegmentTimeValueCheck(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"ingestionConfig"+"."+"segmentTimeValueCheck", "body", m.SegmentTimeValueCheck); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2RealtimeIngestionConfig) validateStreamIngestionConfig(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"ingestionConfig"+"."+"streamIngestionConfig", "body", m.StreamIngestionConfig); err != nil {
		return err
	}

	if m.StreamIngestionConfig != nil {
		if err := m.StreamIngestionConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("realtime" + "." + "ingestionConfig" + "." + "streamIngestionConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("realtime" + "." + "ingestionConfig" + "." + "streamIngestionConfig")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfigV2RealtimeIngestionConfig) validateTransformConfigs(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"ingestionConfig"+"."+"transformConfigs", "body", m.TransformConfigs); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this table config v2 realtime ingestion config based on the context it is used
func (m *TableConfigV2RealtimeIngestionConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateStreamIngestionConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TableConfigV2RealtimeIngestionConfig) contextValidateStreamIngestionConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.StreamIngestionConfig != nil {
		if err := m.StreamIngestionConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("realtime" + "." + "ingestionConfig" + "." + "streamIngestionConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("realtime" + "." + "ingestionConfig" + "." + "streamIngestionConfig")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TableConfigV2RealtimeIngestionConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TableConfigV2RealtimeIngestionConfig) UnmarshalBinary(b []byte) error {
	var res TableConfigV2RealtimeIngestionConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TableConfigV2RealtimeIngestionConfigStreamIngestionConfig table config v2 realtime ingestion config stream ingestion config
//
// swagger:model TableConfigV2RealtimeIngestionConfigStreamIngestionConfig
type TableConfigV2RealtimeIngestionConfigStreamIngestionConfig struct {

	// stream config maps
	// Required: true
	StreamConfigMaps []interface{} `json:"streamConfigMaps"`
}

// Validate validates this table config v2 realtime ingestion config stream ingestion config
func (m *TableConfigV2RealtimeIngestionConfigStreamIngestionConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateStreamConfigMaps(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TableConfigV2RealtimeIngestionConfigStreamIngestionConfig) validateStreamConfigMaps(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"ingestionConfig"+"."+"streamIngestionConfig"+"."+"streamConfigMaps", "body", m.StreamConfigMaps); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this table config v2 realtime ingestion config stream ingestion config based on context it is used
func (m *TableConfigV2RealtimeIngestionConfigStreamIngestionConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TableConfigV2RealtimeIngestionConfigStreamIngestionConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TableConfigV2RealtimeIngestionConfigStreamIngestionConfig) UnmarshalBinary(b []byte) error {
	var res TableConfigV2RealtimeIngestionConfigStreamIngestionConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TableConfigV2RealtimeRouting table config v2 realtime routing
//
// swagger:model TableConfigV2RealtimeRouting
type TableConfigV2RealtimeRouting struct {

	// instance selector type
	// Required: true
	InstanceSelectorType *string `json:"instanceSelectorType"`

	// segment pruner types
	// Required: true
	SegmentPrunerTypes []interface{} `json:"segmentPrunerTypes"`
}

// Validate validates this table config v2 realtime routing
func (m *TableConfigV2RealtimeRouting) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateInstanceSelectorType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSegmentPrunerTypes(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TableConfigV2RealtimeRouting) validateInstanceSelectorType(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"routing"+"."+"instanceSelectorType", "body", m.InstanceSelectorType); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2RealtimeRouting) validateSegmentPrunerTypes(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"routing"+"."+"segmentPrunerTypes", "body", m.SegmentPrunerTypes); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this table config v2 realtime routing based on context it is used
func (m *TableConfigV2RealtimeRouting) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TableConfigV2RealtimeRouting) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TableConfigV2RealtimeRouting) UnmarshalBinary(b []byte) error {
	var res TableConfigV2RealtimeRouting
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TableConfigV2RealtimeSegmentsConfig table config v2 realtime segments config
//
// swagger:model TableConfigV2RealtimeSegmentsConfig
type TableConfigV2RealtimeSegmentsConfig struct {

	// deleted segments retention period
	// Required: true
	DeletedSegmentsRetentionPeriod *string `json:"deletedSegmentsRetentionPeriod"`

	// minimize data movement
	// Required: true
	MinimizeDataMovement *bool `json:"minimizeDataMovement"`

	// replicas per partition
	// Required: true
	ReplicasPerPartition *string `json:"replicasPerPartition"`

	// replication
	// Required: true
	Replication *string `json:"replication"`

	// retention time unit
	// Required: true
	RetentionTimeUnit *string `json:"retentionTimeUnit"`

	// retention time value
	// Required: true
	RetentionTimeValue *string `json:"retentionTimeValue"`

	// schema name
	// Required: true
	SchemaName *string `json:"schemaName"`

	// segment assignment strategy
	// Required: true
	SegmentAssignmentStrategy *string `json:"segmentAssignmentStrategy"`

	// segment push type
	// Required: true
	SegmentPushType *string `json:"segmentPushType"`

	// time column name
	// Required: true
	TimeColumnName *string `json:"timeColumnName"`
}

// Validate validates this table config v2 realtime segments config
func (m *TableConfigV2RealtimeSegmentsConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDeletedSegmentsRetentionPeriod(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMinimizeDataMovement(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReplicasPerPartition(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReplication(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRetentionTimeUnit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRetentionTimeValue(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSchemaName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSegmentAssignmentStrategy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSegmentPushType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimeColumnName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TableConfigV2RealtimeSegmentsConfig) validateDeletedSegmentsRetentionPeriod(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"segmentsConfig"+"."+"deletedSegmentsRetentionPeriod", "body", m.DeletedSegmentsRetentionPeriod); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2RealtimeSegmentsConfig) validateMinimizeDataMovement(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"segmentsConfig"+"."+"minimizeDataMovement", "body", m.MinimizeDataMovement); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2RealtimeSegmentsConfig) validateReplicasPerPartition(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"segmentsConfig"+"."+"replicasPerPartition", "body", m.ReplicasPerPartition); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2RealtimeSegmentsConfig) validateReplication(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"segmentsConfig"+"."+"replication", "body", m.Replication); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2RealtimeSegmentsConfig) validateRetentionTimeUnit(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"segmentsConfig"+"."+"retentionTimeUnit", "body", m.RetentionTimeUnit); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2RealtimeSegmentsConfig) validateRetentionTimeValue(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"segmentsConfig"+"."+"retentionTimeValue", "body", m.RetentionTimeValue); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2RealtimeSegmentsConfig) validateSchemaName(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"segmentsConfig"+"."+"schemaName", "body", m.SchemaName); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2RealtimeSegmentsConfig) validateSegmentAssignmentStrategy(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"segmentsConfig"+"."+"segmentAssignmentStrategy", "body", m.SegmentAssignmentStrategy); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2RealtimeSegmentsConfig) validateSegmentPushType(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"segmentsConfig"+"."+"segmentPushType", "body", m.SegmentPushType); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2RealtimeSegmentsConfig) validateTimeColumnName(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"segmentsConfig"+"."+"timeColumnName", "body", m.TimeColumnName); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this table config v2 realtime segments config based on context it is used
func (m *TableConfigV2RealtimeSegmentsConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TableConfigV2RealtimeSegmentsConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TableConfigV2RealtimeSegmentsConfig) UnmarshalBinary(b []byte) error {
	var res TableConfigV2RealtimeSegmentsConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TableConfigV2RealtimeTableIndexConfig table config v2 realtime table index config
//
// swagger:model TableConfigV2RealtimeTableIndexConfig
type TableConfigV2RealtimeTableIndexConfig struct {

	// aggregate metrics
	// Required: true
	AggregateMetrics *bool `json:"aggregateMetrics"`

	// auto generated inverted index
	// Required: true
	AutoGeneratedInvertedIndex *bool `json:"autoGeneratedInvertedIndex"`

	// create inverted index during segment generation
	// Required: true
	CreateInvertedIndexDuringSegmentGeneration *bool `json:"createInvertedIndexDuringSegmentGeneration"`

	// enable default star tree
	// Required: true
	EnableDefaultStarTree *bool `json:"enableDefaultStarTree"`

	// enable dynamic star tree creation
	// Required: true
	EnableDynamicStarTreeCreation *bool `json:"enableDynamicStarTreeCreation"`

	// inverted index columns
	// Required: true
	InvertedIndexColumns []interface{} `json:"invertedIndexColumns"`

	// load mode
	// Required: true
	LoadMode *string `json:"loadMode"`

	// no dictionary columns
	// Required: true
	NoDictionaryColumns []interface{} `json:"noDictionaryColumns"`

	// no dictionary size ratio threshold
	// Required: true
	NoDictionarySizeRatioThreshold *float64 `json:"noDictionarySizeRatioThreshold"`

	// null handling enabled
	// Required: true
	NullHandlingEnabled *bool `json:"nullHandlingEnabled"`

	// optimize dictionary
	// Required: true
	OptimizeDictionary *bool `json:"optimizeDictionary"`

	// optimize dictionary for metrics
	// Required: true
	OptimizeDictionaryForMetrics *bool `json:"optimizeDictionaryForMetrics"`

	// range index version
	// Required: true
	RangeIndexVersion *int64 `json:"rangeIndexVersion"`

	// segment partition config
	// Required: true
	SegmentPartitionConfig *TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfig `json:"segmentPartitionConfig"`

	// sorted column
	// Required: true
	SortedColumn []interface{} `json:"sortedColumn"`

	// var length dictionary columns
	// Required: true
	VarLengthDictionaryColumns []interface{} `json:"varLengthDictionaryColumns"`
}

// Validate validates this table config v2 realtime table index config
func (m *TableConfigV2RealtimeTableIndexConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAggregateMetrics(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAutoGeneratedInvertedIndex(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreateInvertedIndexDuringSegmentGeneration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEnableDefaultStarTree(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEnableDynamicStarTreeCreation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInvertedIndexColumns(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLoadMode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNoDictionaryColumns(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNoDictionarySizeRatioThreshold(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNullHandlingEnabled(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOptimizeDictionary(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOptimizeDictionaryForMetrics(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRangeIndexVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSegmentPartitionConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortedColumn(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVarLengthDictionaryColumns(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TableConfigV2RealtimeTableIndexConfig) validateAggregateMetrics(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"tableIndexConfig"+"."+"aggregateMetrics", "body", m.AggregateMetrics); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2RealtimeTableIndexConfig) validateAutoGeneratedInvertedIndex(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"tableIndexConfig"+"."+"autoGeneratedInvertedIndex", "body", m.AutoGeneratedInvertedIndex); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2RealtimeTableIndexConfig) validateCreateInvertedIndexDuringSegmentGeneration(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"tableIndexConfig"+"."+"createInvertedIndexDuringSegmentGeneration", "body", m.CreateInvertedIndexDuringSegmentGeneration); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2RealtimeTableIndexConfig) validateEnableDefaultStarTree(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"tableIndexConfig"+"."+"enableDefaultStarTree", "body", m.EnableDefaultStarTree); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2RealtimeTableIndexConfig) validateEnableDynamicStarTreeCreation(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"tableIndexConfig"+"."+"enableDynamicStarTreeCreation", "body", m.EnableDynamicStarTreeCreation); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2RealtimeTableIndexConfig) validateInvertedIndexColumns(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"tableIndexConfig"+"."+"invertedIndexColumns", "body", m.InvertedIndexColumns); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2RealtimeTableIndexConfig) validateLoadMode(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"tableIndexConfig"+"."+"loadMode", "body", m.LoadMode); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2RealtimeTableIndexConfig) validateNoDictionaryColumns(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"tableIndexConfig"+"."+"noDictionaryColumns", "body", m.NoDictionaryColumns); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2RealtimeTableIndexConfig) validateNoDictionarySizeRatioThreshold(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"tableIndexConfig"+"."+"noDictionarySizeRatioThreshold", "body", m.NoDictionarySizeRatioThreshold); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2RealtimeTableIndexConfig) validateNullHandlingEnabled(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"tableIndexConfig"+"."+"nullHandlingEnabled", "body", m.NullHandlingEnabled); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2RealtimeTableIndexConfig) validateOptimizeDictionary(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"tableIndexConfig"+"."+"optimizeDictionary", "body", m.OptimizeDictionary); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2RealtimeTableIndexConfig) validateOptimizeDictionaryForMetrics(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"tableIndexConfig"+"."+"optimizeDictionaryForMetrics", "body", m.OptimizeDictionaryForMetrics); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2RealtimeTableIndexConfig) validateRangeIndexVersion(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"tableIndexConfig"+"."+"rangeIndexVersion", "body", m.RangeIndexVersion); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2RealtimeTableIndexConfig) validateSegmentPartitionConfig(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"tableIndexConfig"+"."+"segmentPartitionConfig", "body", m.SegmentPartitionConfig); err != nil {
		return err
	}

	if m.SegmentPartitionConfig != nil {
		if err := m.SegmentPartitionConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("realtime" + "." + "tableIndexConfig" + "." + "segmentPartitionConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("realtime" + "." + "tableIndexConfig" + "." + "segmentPartitionConfig")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfigV2RealtimeTableIndexConfig) validateSortedColumn(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"tableIndexConfig"+"."+"sortedColumn", "body", m.SortedColumn); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2RealtimeTableIndexConfig) validateVarLengthDictionaryColumns(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"tableIndexConfig"+"."+"varLengthDictionaryColumns", "body", m.VarLengthDictionaryColumns); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this table config v2 realtime table index config based on the context it is used
func (m *TableConfigV2RealtimeTableIndexConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSegmentPartitionConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TableConfigV2RealtimeTableIndexConfig) contextValidateSegmentPartitionConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.SegmentPartitionConfig != nil {
		if err := m.SegmentPartitionConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("realtime" + "." + "tableIndexConfig" + "." + "segmentPartitionConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("realtime" + "." + "tableIndexConfig" + "." + "segmentPartitionConfig")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TableConfigV2RealtimeTableIndexConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TableConfigV2RealtimeTableIndexConfig) UnmarshalBinary(b []byte) error {
	var res TableConfigV2RealtimeTableIndexConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfig table config v2 realtime table index config segment partition config
//
// swagger:model TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfig
type TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfig struct {

	// column partition map
	// Required: true
	ColumnPartitionMap *TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfigColumnPartitionMap `json:"columnPartitionMap"`
}

// Validate validates this table config v2 realtime table index config segment partition config
func (m *TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateColumnPartitionMap(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfig) validateColumnPartitionMap(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"tableIndexConfig"+"."+"segmentPartitionConfig"+"."+"columnPartitionMap", "body", m.ColumnPartitionMap); err != nil {
		return err
	}

	if m.ColumnPartitionMap != nil {
		if err := m.ColumnPartitionMap.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("realtime" + "." + "tableIndexConfig" + "." + "segmentPartitionConfig" + "." + "columnPartitionMap")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("realtime" + "." + "tableIndexConfig" + "." + "segmentPartitionConfig" + "." + "columnPartitionMap")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this table config v2 realtime table index config segment partition config based on the context it is used
func (m *TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateColumnPartitionMap(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfig) contextValidateColumnPartitionMap(ctx context.Context, formats strfmt.Registry) error {

	if m.ColumnPartitionMap != nil {
		if err := m.ColumnPartitionMap.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("realtime" + "." + "tableIndexConfig" + "." + "segmentPartitionConfig" + "." + "columnPartitionMap")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("realtime" + "." + "tableIndexConfig" + "." + "segmentPartitionConfig" + "." + "columnPartitionMap")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfig) UnmarshalBinary(b []byte) error {
	var res TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfigColumnPartitionMap table config v2 realtime table index config segment partition config column partition map
//
// swagger:model TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfigColumnPartitionMap
type TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfigColumnPartitionMap struct {

	// city
	// Required: true
	City *TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfigColumnPartitionMapCity `json:"city"`

	// id
	// Required: true
	ID *TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfigColumnPartitionMapID `json:"id"`
}

// Validate validates this table config v2 realtime table index config segment partition config column partition map
func (m *TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfigColumnPartitionMap) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfigColumnPartitionMap) validateCity(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"tableIndexConfig"+"."+"segmentPartitionConfig"+"."+"columnPartitionMap"+"."+"city", "body", m.City); err != nil {
		return err
	}

	if m.City != nil {
		if err := m.City.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("realtime" + "." + "tableIndexConfig" + "." + "segmentPartitionConfig" + "." + "columnPartitionMap" + "." + "city")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("realtime" + "." + "tableIndexConfig" + "." + "segmentPartitionConfig" + "." + "columnPartitionMap" + "." + "city")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfigColumnPartitionMap) validateID(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"tableIndexConfig"+"."+"segmentPartitionConfig"+"."+"columnPartitionMap"+"."+"id", "body", m.ID); err != nil {
		return err
	}

	if m.ID != nil {
		if err := m.ID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("realtime" + "." + "tableIndexConfig" + "." + "segmentPartitionConfig" + "." + "columnPartitionMap" + "." + "id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("realtime" + "." + "tableIndexConfig" + "." + "segmentPartitionConfig" + "." + "columnPartitionMap" + "." + "id")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this table config v2 realtime table index config segment partition config column partition map based on the context it is used
func (m *TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfigColumnPartitionMap) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCity(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfigColumnPartitionMap) contextValidateCity(ctx context.Context, formats strfmt.Registry) error {

	if m.City != nil {
		if err := m.City.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("realtime" + "." + "tableIndexConfig" + "." + "segmentPartitionConfig" + "." + "columnPartitionMap" + "." + "city")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("realtime" + "." + "tableIndexConfig" + "." + "segmentPartitionConfig" + "." + "columnPartitionMap" + "." + "city")
			}
			return err
		}
	}

	return nil
}

func (m *TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfigColumnPartitionMap) contextValidateID(ctx context.Context, formats strfmt.Registry) error {

	if m.ID != nil {
		if err := m.ID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("realtime" + "." + "tableIndexConfig" + "." + "segmentPartitionConfig" + "." + "columnPartitionMap" + "." + "id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("realtime" + "." + "tableIndexConfig" + "." + "segmentPartitionConfig" + "." + "columnPartitionMap" + "." + "id")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfigColumnPartitionMap) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfigColumnPartitionMap) UnmarshalBinary(b []byte) error {
	var res TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfigColumnPartitionMap
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfigColumnPartitionMapCity table config v2 realtime table index config segment partition config column partition map city
//
// swagger:model TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfigColumnPartitionMapCity
type TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfigColumnPartitionMapCity struct {

	// function name
	// Required: true
	FunctionName *string `json:"functionName"`

	// num partitions
	// Required: true
	NumPartitions *int64 `json:"numPartitions"`
}

// Validate validates this table config v2 realtime table index config segment partition config column partition map city
func (m *TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfigColumnPartitionMapCity) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFunctionName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNumPartitions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfigColumnPartitionMapCity) validateFunctionName(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"tableIndexConfig"+"."+"segmentPartitionConfig"+"."+"columnPartitionMap"+"."+"city"+"."+"functionName", "body", m.FunctionName); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfigColumnPartitionMapCity) validateNumPartitions(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"tableIndexConfig"+"."+"segmentPartitionConfig"+"."+"columnPartitionMap"+"."+"city"+"."+"numPartitions", "body", m.NumPartitions); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this table config v2 realtime table index config segment partition config column partition map city based on context it is used
func (m *TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfigColumnPartitionMapCity) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfigColumnPartitionMapCity) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfigColumnPartitionMapCity) UnmarshalBinary(b []byte) error {
	var res TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfigColumnPartitionMapCity
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfigColumnPartitionMapID table config v2 realtime table index config segment partition config column partition map ID
//
// swagger:model TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfigColumnPartitionMapID
type TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfigColumnPartitionMapID struct {

	// function name
	// Required: true
	FunctionName *string `json:"functionName"`

	// num partitions
	// Required: true
	NumPartitions *int64 `json:"numPartitions"`
}

// Validate validates this table config v2 realtime table index config segment partition config column partition map ID
func (m *TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfigColumnPartitionMapID) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFunctionName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNumPartitions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfigColumnPartitionMapID) validateFunctionName(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"tableIndexConfig"+"."+"segmentPartitionConfig"+"."+"columnPartitionMap"+"."+"id"+"."+"functionName", "body", m.FunctionName); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfigColumnPartitionMapID) validateNumPartitions(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"tableIndexConfig"+"."+"segmentPartitionConfig"+"."+"columnPartitionMap"+"."+"id"+"."+"numPartitions", "body", m.NumPartitions); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this table config v2 realtime table index config segment partition config column partition map ID based on context it is used
func (m *TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfigColumnPartitionMapID) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfigColumnPartitionMapID) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfigColumnPartitionMapID) UnmarshalBinary(b []byte) error {
	var res TableConfigV2RealtimeTableIndexConfigSegmentPartitionConfigColumnPartitionMapID
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TableConfigV2RealtimeTenants table config v2 realtime tenants
//
// swagger:model TableConfigV2RealtimeTenants
type TableConfigV2RealtimeTenants struct {

	// broker
	// Required: true
	Broker *string `json:"broker"`

	// server
	// Required: true
	Server *string `json:"server"`
}

// Validate validates this table config v2 realtime tenants
func (m *TableConfigV2RealtimeTenants) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBroker(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServer(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TableConfigV2RealtimeTenants) validateBroker(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"tenants"+"."+"broker", "body", m.Broker); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2RealtimeTenants) validateServer(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"tenants"+"."+"server", "body", m.Server); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this table config v2 realtime tenants based on context it is used
func (m *TableConfigV2RealtimeTenants) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TableConfigV2RealtimeTenants) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TableConfigV2RealtimeTenants) UnmarshalBinary(b []byte) error {
	var res TableConfigV2RealtimeTenants
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TableConfigV2RealtimeUpsertConfig table config v2 realtime upsert config
//
// swagger:model TableConfigV2RealtimeUpsertConfig
type TableConfigV2RealtimeUpsertConfig struct {

	// enable snapshot
	// Required: true
	EnableSnapshot *bool `json:"enableSnapshot"`

	// hash function
	// Required: true
	HashFunction *string `json:"hashFunction"`

	// mode
	// Required: true
	Mode *string `json:"mode"`
}

// Validate validates this table config v2 realtime upsert config
func (m *TableConfigV2RealtimeUpsertConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateEnableSnapshot(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHashFunction(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TableConfigV2RealtimeUpsertConfig) validateEnableSnapshot(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"upsertConfig"+"."+"enableSnapshot", "body", m.EnableSnapshot); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2RealtimeUpsertConfig) validateHashFunction(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"upsertConfig"+"."+"hashFunction", "body", m.HashFunction); err != nil {
		return err
	}

	return nil
}

func (m *TableConfigV2RealtimeUpsertConfig) validateMode(formats strfmt.Registry) error {

	if err := validate.Required("realtime"+"."+"upsertConfig"+"."+"mode", "body", m.Mode); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this table config v2 realtime upsert config based on context it is used
func (m *TableConfigV2RealtimeUpsertConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TableConfigV2RealtimeUpsertConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TableConfigV2RealtimeUpsertConfig) UnmarshalBinary(b []byte) error {
	var res TableConfigV2RealtimeUpsertConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TableConfigV2Schema table config v2 schema
//
// swagger:model TableConfigV2Schema
type TableConfigV2Schema struct {

	// date time field specs
	DateTimeFieldSpecs []interface{} `json:"dateTimeFieldSpecs"`

	// dimension field specs
	DimensionFieldSpecs []interface{} `json:"dimensionFieldSpecs"`

	// metric field specs
	MetricFieldSpecs []interface{} `json:"metricFieldSpecs"`

	// primary key columns
	PrimaryKeyColumns []interface{} `json:"primaryKeyColumns"`

	// schema name
	// Required: true
	SchemaName *string `json:"schemaName"`
}

// Validate validates this table config v2 schema
func (m *TableConfigV2Schema) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSchemaName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TableConfigV2Schema) validateSchemaName(formats strfmt.Registry) error {

	if err := validate.Required("schema"+"."+"schemaName", "body", m.SchemaName); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this table config v2 schema based on context it is used
func (m *TableConfigV2Schema) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TableConfigV2Schema) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TableConfigV2Schema) UnmarshalBinary(b []byte) error {
	var res TableConfigV2Schema
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
