// Code generated by go-swagger; DO NOT EDIT.

package cli

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"fmt"

	"startree.ai/cli/client/table"
	"startree.ai/cli/models"

	"github.com/go-openapi/swag"
	"github.com/spf13/cobra"
)

// makeOperationTableValidateTableAndSchemaCmd returns a cmd to handle operation validateTableAndSchema
func makeOperationTableValidateTableAndSchemaCmd() (*cobra.Command, error) {
	cmd := &cobra.Command{
		Use:   "validateTableAndSchema",
		Short: `Deprecated. Use /tableConfigs/validate instead.Validate given table config and schema. If specified schema is null, attempt to retrieve schema using the table name. This API returns the table config that matches the one you get from 'GET /tables/{tableName}'. This allows us to validate table config before apply.`,
		RunE:  runOperationTableValidateTableAndSchema,
	}

	if err := registerOperationTableValidateTableAndSchemaParamFlags(cmd); err != nil {
		return nil, err
	}

	return cmd, nil
}

// runOperationTableValidateTableAndSchema uses cmd flags to call endpoint api
func runOperationTableValidateTableAndSchema(cmd *cobra.Command, args []string) error {
	appCli, err := makeClient(cmd, args)
	if err != nil {
		return err
	}
	// retrieve flag values from cmd and fill params
	params := table.NewValidateTableAndSchemaParams()
	if err, _ := retrieveOperationTableValidateTableAndSchemaBodyFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ := retrieveOperationTableValidateTableAndSchemaValidationTypesToSkipFlag(params, "", cmd); err != nil {
		return err
	}
	if dryRun {

		logDebugf("dry-run flag specified. Skip sending request.")
		return nil
	}
	// make request and then print result
	msgStr, err := parseOperationTableValidateTableAndSchemaResult(appCli.Table.ValidateTableAndSchema(params, nil))
	if err != nil {
		return err
	}
	if !debug {

		fmt.Println(msgStr)
	}
	return nil
}

// registerOperationTableValidateTableAndSchemaParamFlags registers all flags needed to fill params
func registerOperationTableValidateTableAndSchemaParamFlags(cmd *cobra.Command) error {
	if err := registerOperationTableValidateTableAndSchemaBodyParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationTableValidateTableAndSchemaValidationTypesToSkipParamFlags("", cmd); err != nil {
		return err
	}
	return nil
}

func registerOperationTableValidateTableAndSchemaBodyParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	var bodyFlagName string
	if cmdPrefix == "" {
		bodyFlagName = "body"
	} else {
		bodyFlagName = fmt.Sprintf("%v.body", cmdPrefix)
	}

	_ = cmd.PersistentFlags().String(bodyFlagName, "", "Optional json string for [body]. ")

	// add flags for body
	if err := registerModelTableAndSchemaConfigFlags(0, "tableAndSchemaConfig", cmd); err != nil {
		return err
	}

	return nil
}
func registerOperationTableValidateTableAndSchemaValidationTypesToSkipParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	validationTypesToSkipDescription := `comma separated list of validation type(s) to skip. supported types: (ALL|TASK|UPSERT)`

	var validationTypesToSkipFlagName string
	if cmdPrefix == "" {
		validationTypesToSkipFlagName = "validationTypesToSkip"
	} else {
		validationTypesToSkipFlagName = fmt.Sprintf("%v.validationTypesToSkip", cmdPrefix)
	}

	var validationTypesToSkipFlagDefault string

	_ = cmd.PersistentFlags().String(validationTypesToSkipFlagName, validationTypesToSkipFlagDefault, validationTypesToSkipDescription)

	return nil
}

func retrieveOperationTableValidateTableAndSchemaBodyFlag(m *table.ValidateTableAndSchemaParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("body") {
		// Read body string from cmd and unmarshal
		bodyValueStr, err := cmd.Flags().GetString("body")
		if err != nil {
			return err, false
		}

		bodyValue := models.TableAndSchemaConfig{}
		if err := json.Unmarshal([]byte(bodyValueStr), &bodyValue); err != nil {
			return fmt.Errorf("cannot unmarshal body string in models.TableAndSchemaConfig: %v", err), false
		}
		m.Body = &bodyValue
	}
	bodyValueModel := m.Body
	if swag.IsZero(bodyValueModel) {
		bodyValueModel = &models.TableAndSchemaConfig{}
	}
	err, added := retrieveModelTableAndSchemaConfigFlags(0, bodyValueModel, "tableAndSchemaConfig", cmd)
	if err != nil {
		return err, false
	}
	if added {
		m.Body = bodyValueModel
	}
	if dryRun && debug {

		bodyValueDebugBytes, err := json.Marshal(m.Body)
		if err != nil {
			return err, false
		}
		logDebugf("Body dry-run payload: %v", string(bodyValueDebugBytes))
	}
	retAdded = retAdded || added

	return nil, retAdded
}
func retrieveOperationTableValidateTableAndSchemaValidationTypesToSkipFlag(m *table.ValidateTableAndSchemaParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("validationTypesToSkip") {

		var validationTypesToSkipFlagName string
		if cmdPrefix == "" {
			validationTypesToSkipFlagName = "validationTypesToSkip"
		} else {
			validationTypesToSkipFlagName = fmt.Sprintf("%v.validationTypesToSkip", cmdPrefix)
		}

		validationTypesToSkipFlagValue, err := cmd.Flags().GetString(validationTypesToSkipFlagName)
		if err != nil {
			return err, false
		}
		m.ValidationTypesToSkip = &validationTypesToSkipFlagValue

	}
	return nil, retAdded
}

// parseOperationTableValidateTableAndSchemaResult parses request result and return the string content
func parseOperationTableValidateTableAndSchemaResult(resp0 *table.ValidateTableAndSchemaOK, respErr error) (string, error) {
	if respErr != nil {

		var iResp0 interface{} = respErr
		resp0, ok := iResp0.(*table.ValidateTableAndSchemaOK)
		if ok {
			if !swag.IsZero(resp0) && !swag.IsZero(resp0.Payload) {
				msgStr, err := json.Marshal(resp0.Payload)
				if err != nil {
					return "", err
				}
				return string(msgStr), nil
			}
		}

		return "", respErr
	}

	if !swag.IsZero(resp0) && !swag.IsZero(resp0.Payload) {
		msgStr := fmt.Sprintf("%v", resp0.Payload)
		return string(msgStr), nil
	}

	return "", nil
}
