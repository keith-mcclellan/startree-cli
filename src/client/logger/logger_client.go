// Code generated by go-swagger; DO NOT EDIT.

package logger

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new logger API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for logger API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption is the option for Client methods
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	DownloadLogFile(params *DownloadLogFileParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) error

	DownloadLogFileFromInstance(params *DownloadLogFileFromInstanceParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) error

	GetLocalLogFiles(params *GetLocalLogFilesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetLocalLogFilesOK, error)

	GetLogFilesFromAllInstances(params *GetLogFilesFromAllInstancesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetLogFilesFromAllInstancesOK, error)

	GetLogFilesFromInstance(params *GetLogFilesFromInstanceParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetLogFilesFromInstanceOK, error)

	GetLogger(params *GetLoggerParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetLoggerOK, error)

	GetLoggers(params *GetLoggersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetLoggersOK, error)

	SetLoggerLevel(params *SetLoggerLevelParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SetLoggerLevelOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
DownloadLogFile downloads a log file
*/
func (a *Client) DownloadLogFile(params *DownloadLogFileParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDownloadLogFileParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "downloadLogFile",
		Method:             "GET",
		PathPattern:        "/loggers/download",
		ProducesMediaTypes: []string{"application/octet-stream"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DownloadLogFileReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	_, err := a.transport.Submit(op)
	if err != nil {
		return err
	}
	return nil
}

/*
DownloadLogFileFromInstance downloads a log file from a given instance
*/
func (a *Client) DownloadLogFileFromInstance(params *DownloadLogFileFromInstanceParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDownloadLogFileFromInstanceParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "downloadLogFileFromInstance",
		Method:             "GET",
		PathPattern:        "/loggers/instances/{instanceName}/download",
		ProducesMediaTypes: []string{"application/octet-stream"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DownloadLogFileFromInstanceReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	_, err := a.transport.Submit(op)
	if err != nil {
		return err
	}
	return nil
}

/*
GetLocalLogFiles gets all local log files
*/
func (a *Client) GetLocalLogFiles(params *GetLocalLogFilesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetLocalLogFilesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetLocalLogFilesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getLocalLogFiles",
		Method:             "GET",
		PathPattern:        "/loggers/files",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetLocalLogFilesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetLocalLogFilesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getLocalLogFiles: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetLogFilesFromAllInstances collects log files from all the instances
*/
func (a *Client) GetLogFilesFromAllInstances(params *GetLogFilesFromAllInstancesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetLogFilesFromAllInstancesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetLogFilesFromAllInstancesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getLogFilesFromAllInstances",
		Method:             "GET",
		PathPattern:        "/loggers/instances",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetLogFilesFromAllInstancesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetLogFilesFromAllInstancesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getLogFilesFromAllInstances: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetLogFilesFromInstance collects log files from a given instance
*/
func (a *Client) GetLogFilesFromInstance(params *GetLogFilesFromInstanceParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetLogFilesFromInstanceOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetLogFilesFromInstanceParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getLogFilesFromInstance",
		Method:             "GET",
		PathPattern:        "/loggers/instances/{instanceName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetLogFilesFromInstanceReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetLogFilesFromInstanceOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getLogFilesFromInstance: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetLogger gets logger configs

Return logger info
*/
func (a *Client) GetLogger(params *GetLoggerParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetLoggerOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetLoggerParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getLogger",
		Method:             "GET",
		PathPattern:        "/loggers/{loggerName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetLoggerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetLoggerOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getLogger: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetLoggers gets all the loggers

Return all the logger names
*/
func (a *Client) GetLoggers(params *GetLoggersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetLoggersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetLoggersParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getLoggers",
		Method:             "GET",
		PathPattern:        "/loggers",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetLoggersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetLoggersOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getLoggers: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
SetLoggerLevel sets logger level

Set logger level for a given logger
*/
func (a *Client) SetLoggerLevel(params *SetLoggerLevelParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SetLoggerLevelOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSetLoggerLevelParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "setLoggerLevel",
		Method:             "PUT",
		PathPattern:        "/loggers/{loggerName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SetLoggerLevelReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SetLoggerLevelOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for setLoggerLevel: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
